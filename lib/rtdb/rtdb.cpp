/*
 * This file was autogenerated by RTDB Generator script
 * Date of generation: 01 December 2024 at 11:50:18
 * To modify this file run the RTDB Generator script again
 */

#include"rtdb.h"

static bool rtdb_s_moduleInit_tB = false;
static uint32_t rtdb_nr_moduleId_U32 = 0;

const char* rtdb_unitLookupTable[VAR_UNIT_MAX_NUM] =
{
    [VAR_UNIT_us] = "us",
};

tU8S* rtdb_arr_tU8S[NUM_OF_tU8S];
tU16S* rtdb_arr_tU16S[NUM_OF_tU16S];
tU32S* rtdb_arr_tU32S[NUM_OF_tU32S];
tS8S* rtdb_arr_tS8S[NUM_OF_tS8S];
tS16S* rtdb_arr_tS16S[NUM_OF_tS16S];
tS32S* rtdb_arr_tS32S[NUM_OF_tS32S];
tES* rtdb_arr_tES[NUM_OF_tES];
tBS* rtdb_arr_tBS[NUM_OF_tBS];
tF32S* rtdb_arr_tF32S[NUM_OF_tF32S];

tU32 rtdb_calcCrc32 (void* VarAddrs, tU32 VarSize )
{
    // TODO
    return -1;
}

void rtdb_assign_tU8S( tU8S* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tU8 Min,
                         tU8 Def,
                         tU8 Max,
                         const char* Comment )
{
    rtdb_arr_tU8S[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tU8_val = Def;
    VarAddrs->tU8_min = Min;
    VarAddrs->tU8_def = Def;
    VarAddrs->tU8_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tU8S));
};

void rtdb_assign_tU16S( tU16S* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tU16 Min,
                         tU16 Def,
                         tU16 Max,
                         const char* Comment )
{
    rtdb_arr_tU16S[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tU16_val = Def;
    VarAddrs->tU16_min = Min;
    VarAddrs->tU16_def = Def;
    VarAddrs->tU16_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tU16S));
};

void rtdb_assign_tU32S( tU32S* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tU32 Min,
                         tU32 Def,
                         tU32 Max,
                         const char* Comment )
{
    rtdb_arr_tU32S[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tU32_val = Def;
    VarAddrs->tU32_min = Min;
    VarAddrs->tU32_def = Def;
    VarAddrs->tU32_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tU32S));
};

void rtdb_assign_tS8S( tS8S* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tS8 Min,
                         tS8 Def,
                         tS8 Max,
                         const char* Comment )
{
    rtdb_arr_tS8S[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tS8_val = Def;
    VarAddrs->tS8_min = Min;
    VarAddrs->tS8_def = Def;
    VarAddrs->tS8_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tS8S));
};

void rtdb_assign_tS16S( tS16S* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tS16 Min,
                         tS16 Def,
                         tS16 Max,
                         const char* Comment )
{
    rtdb_arr_tS16S[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tS16_val = Def;
    VarAddrs->tS16_min = Min;
    VarAddrs->tS16_def = Def;
    VarAddrs->tS16_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tS16S));
};

void rtdb_assign_tS32S( tS32S* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tS32 Min,
                         tS32 Def,
                         tS32 Max,
                         const char* Comment )
{
    rtdb_arr_tS32S[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tS32_val = Def;
    VarAddrs->tS32_min = Min;
    VarAddrs->tS32_def = Def;
    VarAddrs->tS32_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tS32S));
};

void rtdb_assign_tES( tES* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tE Min,
                         tE Def,
                         tE Max,
                         const char* Comment )
{
    rtdb_arr_tES[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tE_val = Def;
    VarAddrs->tE_min = Min;
    VarAddrs->tE_def = Def;
    VarAddrs->tE_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tES));
};

void rtdb_assign_tBS( tBS* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tB Min,
                         tB Def,
                         tB Max,
                         const char* Comment )
{
    rtdb_arr_tBS[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tB_val = Def;
    VarAddrs->tB_min = Min;
    VarAddrs->tB_def = Def;
    VarAddrs->tB_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tBS));
};

void rtdb_assign_tF32S( tF32S* VarAddrs,
                         tU32 Indx,
                         unitEnumT Unit,
                         tF32 Min,
                         tF32 Def,
                         tF32 Max,
                         const char* Comment )
{
    rtdb_arr_tF32S[Indx] = VarAddrs; // Copy address of variable to lookup table
    VarAddrs->tF32_val = Def;
    VarAddrs->tF32_min = Min;
    VarAddrs->tF32_def = Def;
    VarAddrs->tF32_max = Max;
    VarAddrs->ss.signalUnit = Unit;
    VarAddrs->ss.signalCmnt = Comment;
    VarAddrs->ss.signalState = SIGNAL_OK;
    VarAddrs->ss.objectStatus = OBJECT_STANDARD;
    VarAddrs->ss.crc32 = rtdb_calcCrc32(VarAddrs, sizeof(tF32S));
};


tU32 rtdb_write_tU8S( tU8SEnumT VarName , tU8 NewVal)
{
    tU32 stsCode = 0;
    tU8 valToWrite = rtdb_arr_tU8S[VarName]->tU8_val;
    // Request out of range
    if (NUM_OF_tU8S <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tU8S[VarName], sizeof(tU8S)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tU8S[VarName]->tU8_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tU8S[VarName]->tU8_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tU8S[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tU8S[VarName], sizeof(tU8S));
        }
    }

    rtdb_arr_tU8S[VarName]->tU8_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tU16S( tU16SEnumT VarName , tU16 NewVal)
{
    tU32 stsCode = 0;
    tU16 valToWrite = rtdb_arr_tU16S[VarName]->tU16_val;
    // Request out of range
    if (NUM_OF_tU16S <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tU16S[VarName], sizeof(tU16S)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tU16S[VarName]->tU16_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tU16S[VarName]->tU16_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tU16S[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tU16S[VarName], sizeof(tU16S));
        }
    }

    rtdb_arr_tU16S[VarName]->tU16_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tU32S( tU32SEnumT VarName , tU32 NewVal)
{
    tU32 stsCode = 0;
    tU32 valToWrite = rtdb_arr_tU32S[VarName]->tU32_val;
    // Request out of range
    if (NUM_OF_tU32S <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tU32S[VarName], sizeof(tU32S)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tU32S[VarName]->tU32_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tU32S[VarName]->tU32_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tU32S[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tU32S[VarName], sizeof(tU32S));
        }
    }

    rtdb_arr_tU32S[VarName]->tU32_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tS8S( tS8SEnumT VarName , tS8 NewVal)
{
    tU32 stsCode = 0;
    tS8 valToWrite = rtdb_arr_tS8S[VarName]->tS8_val;
    // Request out of range
    if (NUM_OF_tS8S <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tS8S[VarName], sizeof(tS8S)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tS8S[VarName]->tS8_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tS8S[VarName]->tS8_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tS8S[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tS8S[VarName], sizeof(tS8S));
        }
    }

    rtdb_arr_tS8S[VarName]->tS8_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tS16S( tS16SEnumT VarName , tS16 NewVal)
{
    tU32 stsCode = 0;
    tS16 valToWrite = rtdb_arr_tS16S[VarName]->tS16_val;
    // Request out of range
    if (NUM_OF_tS16S <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tS16S[VarName], sizeof(tS16S)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tS16S[VarName]->tS16_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tS16S[VarName]->tS16_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tS16S[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tS16S[VarName], sizeof(tS16S));
        }
    }

    rtdb_arr_tS16S[VarName]->tS16_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tS32S( tS32SEnumT VarName , tS32 NewVal)
{
    tU32 stsCode = 0;
    tS32 valToWrite = rtdb_arr_tS32S[VarName]->tS32_val;
    // Request out of range
    if (NUM_OF_tS32S <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tS32S[VarName], sizeof(tS32S)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tS32S[VarName]->tS32_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tS32S[VarName]->tS32_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tS32S[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tS32S[VarName], sizeof(tS32S));
        }
    }

    rtdb_arr_tS32S[VarName]->tS32_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tES( tESEnumT VarName , tE NewVal)
{
    tU32 stsCode = 0;
    tE valToWrite = rtdb_arr_tES[VarName]->tE_val;
    // Request out of range
    if (NUM_OF_tES <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tES[VarName], sizeof(tES)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tES[VarName]->tE_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tES[VarName]->tE_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tES[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tES[VarName], sizeof(tES));
        }
    }

    rtdb_arr_tES[VarName]->tE_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tBS( tBSEnumT VarName , tB NewVal)
{
    tU32 stsCode = 0;
    tB valToWrite = rtdb_arr_tBS[VarName]->tB_val;
    // Request out of range
    if (NUM_OF_tBS <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tBS[VarName], sizeof(tBS)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tBS[VarName]->tB_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tBS[VarName]->tB_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tBS[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tBS[VarName], sizeof(tBS));
        }
    }

    rtdb_arr_tBS[VarName]->tB_val = valToWrite;
    return stsCode;
}

tU32 rtdb_write_tF32S( tF32SEnumT VarName , tF32 NewVal)
{
    tU32 stsCode = 0;
    tF32 valToWrite = rtdb_arr_tF32S[VarName]->tF32_val;
    // Request out of range
    if (NUM_OF_tF32S <= VarName)
    {
        // TODO
    }
    // check CRC
    else if (rtdb_checkCrc32(rtdb_arr_tF32S[VarName], sizeof(tF32S)))
    {
        // TODO
    }
    // check for MIN
    else if ( NewVal < rtdb_arr_tF32S[VarName]->tF32_min)
    {
        // TODO: Report error
        stsCode = 2;
    }
    // check for MAX
    else if ( NewVal > rtdb_arr_tF32S[VarName]->tF32_max)
    {
        // TODO: Report error
        stsCode = 3;
    }
    else
    {
        if (OBJECT_STANDARD == rtdb_arr_tF32S[VarName]->ss.objectStatus)
        {
            valToWrite = NewVal;
            rtdb_calcCrc32( rtdb_arr_tF32S[VarName], sizeof(tF32S));
        }
    }

    rtdb_arr_tF32S[VarName]->tF32_val = valToWrite;
    return stsCode;
}

tU32 rtdb_overwrite_tU8S( tU8SEnumT VarName , tU8 NewVal )
{
    tU32 stsCode = 0;
    tU8 valToWrite = rtdb_arr_tU8S[VarName]->tU8_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tU8S[VarName], sizeof(tU8S))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tU8S[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tU8S[VarName]->tU8_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tU8S[VarName], sizeof(tU8S));
    return stsCode;
}

tU32 rtdb_overwrite_tU16S( tU16SEnumT VarName , tU16 NewVal )
{
    tU32 stsCode = 0;
    tU16 valToWrite = rtdb_arr_tU16S[VarName]->tU16_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tU16S[VarName], sizeof(tU16S))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tU16S[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tU16S[VarName]->tU16_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tU16S[VarName], sizeof(tU16S));
    return stsCode;
}

tU32 rtdb_overwrite_tU32S( tU32SEnumT VarName , tU32 NewVal )
{
    tU32 stsCode = 0;
    tU32 valToWrite = rtdb_arr_tU32S[VarName]->tU32_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tU32S[VarName], sizeof(tU32S))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tU32S[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tU32S[VarName]->tU32_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tU32S[VarName], sizeof(tU32S));
    return stsCode;
}

tU32 rtdb_overwrite_tS8S( tS8SEnumT VarName , tS8 NewVal )
{
    tU32 stsCode = 0;
    tS8 valToWrite = rtdb_arr_tS8S[VarName]->tS8_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tS8S[VarName], sizeof(tS8S))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tS8S[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tS8S[VarName]->tS8_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tS8S[VarName], sizeof(tS8S));
    return stsCode;
}

tU32 rtdb_overwrite_tS16S( tS16SEnumT VarName , tS16 NewVal )
{
    tU32 stsCode = 0;
    tS16 valToWrite = rtdb_arr_tS16S[VarName]->tS16_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tS16S[VarName], sizeof(tS16S))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tS16S[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tS16S[VarName]->tS16_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tS16S[VarName], sizeof(tS16S));
    return stsCode;
}

tU32 rtdb_overwrite_tS32S( tS32SEnumT VarName , tS32 NewVal )
{
    tU32 stsCode = 0;
    tS32 valToWrite = rtdb_arr_tS32S[VarName]->tS32_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tS32S[VarName], sizeof(tS32S))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tS32S[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tS32S[VarName]->tS32_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tS32S[VarName], sizeof(tS32S));
    return stsCode;
}

tU32 rtdb_overwrite_tES( tESEnumT VarName , tE NewVal )
{
    tU32 stsCode = 0;
    tE valToWrite = rtdb_arr_tES[VarName]->tE_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tES[VarName], sizeof(tES))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tES[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tES[VarName]->tE_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tES[VarName], sizeof(tES));
    return stsCode;
}

tU32 rtdb_overwrite_tBS( tBSEnumT VarName , tB NewVal )
{
    tU32 stsCode = 0;
    tB valToWrite = rtdb_arr_tBS[VarName]->tB_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tBS[VarName], sizeof(tBS))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tBS[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tBS[VarName]->tB_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tBS[VarName], sizeof(tBS));
    return stsCode;
}

tU32 rtdb_overwrite_tF32S( tF32SEnumT VarName , tF32 NewVal )
{
    tU32 stsCode = 0;
    tF32 valToWrite = rtdb_arr_tF32S[VarName]->tF32_val;
    // check CRC
    if (rtdb_checkCrc32( rtdb_arr_tF32S[VarName], sizeof(tF32S))) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        valToWrite = NewVal;
        rtdb_arr_tF32S[VarName]->ss.objectStatus = OBJECT_OVERRIDDEN;
    }

    rtdb_arr_tF32S[VarName]->tF32_val = valToWrite;

    //Recalculate CRC32
    rtdb_calcCrc32( rtdb_arr_tF32S[VarName], sizeof(tF32S));
    return stsCode;
}

tU32 rtdb_releaseOverwrite_tU8S( tU8SEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tU8S[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tU16S( tU16SEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tU16S[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tU32S( tU32SEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tU32S[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tS8S( tS8SEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tS8S[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tS16S( tS16SEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tS16S[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tS32S( tS32SEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tS32S[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tES( tESEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tES[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tBS( tBSEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tBS[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

tU32 rtdb_releaseOverwrite_tF32S( tF32SEnumT VarName )
{
    tU32 stsCode = 0;
    // check CRC
    if (0) // TODO
    {
        // TODO
        stsCode = 1;
    }
    else
    {
        rtdb_arr_tF32S[VarName]->ss.objectStatus = OBJECT_STANDARD;
        // TODO: Recalculate CRC
    }

    return stsCode;
}

/**
* @brief Function returns current value of given variable
* @param tU8SEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tU8 rtdb_read_tU8S( tU8SEnumT VarName )
{
    tU8 toReturn = rtdb_arr_tU8S[VarName]->tU8_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tU16SEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tU16 rtdb_read_tU16S( tU16SEnumT VarName )
{
    tU16 toReturn = rtdb_arr_tU16S[VarName]->tU16_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tU32SEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tU32 rtdb_read_tU32S( tU32SEnumT VarName )
{
    tU32 toReturn = rtdb_arr_tU32S[VarName]->tU32_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tS8SEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tS8 rtdb_read_tS8S( tS8SEnumT VarName )
{
    tS8 toReturn = rtdb_arr_tS8S[VarName]->tS8_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tS16SEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tS16 rtdb_read_tS16S( tS16SEnumT VarName )
{
    tS16 toReturn = rtdb_arr_tS16S[VarName]->tS16_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tS32SEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tS32 rtdb_read_tS32S( tS32SEnumT VarName )
{
    tS32 toReturn = rtdb_arr_tS32S[VarName]->tS32_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tESEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tE rtdb_read_tES( tESEnumT VarName )
{
    tE toReturn = rtdb_arr_tES[VarName]->tE_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tBSEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tB rtdb_read_tBS( tBSEnumT VarName )
{
    tB toReturn = rtdb_arr_tBS[VarName]->tB_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

/**
* @brief Function returns current value of given variable
* @param tF32SEnumT VarName name of the variable as an enum
* @return Verified value of the given variable
*/
tF32 rtdb_read_tF32S( tF32SEnumT VarName )
{
    tF32 toReturn = rtdb_arr_tF32S[VarName]->tF32_val;
    // Check CRC
    if (0)
    {
        // TODO: implement CRC failed case
    }

    return toReturn;
}

void rtdb_init(tRTDB_INITDATA_STR* RtdbCfg)
{
    if (true == rtdb_s_moduleInit_tB)
    {
        errh_reportError(ERRH_NOTIF, rtdb_nr_moduleId_U32, 0, RTDB_API_INIT_U32, ERRH_MODULE_ALREADY_INIT);
    }
    else if (NULL == RtdbCfg)
    {
        errh_reportError(ERRH_ERROR_CRITICAL, rtdb_nr_moduleId_U32, 0, RTDB_API_INIT_U32, ERRH_POINTER_IS_NULL);
    }
    else
    {
        rtdb_s_moduleInit_tB = true;
    }
}
